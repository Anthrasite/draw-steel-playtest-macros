{ "_id": "lBfmIKZDFeOow27S", "name": "DoPowerRoll", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=lBfmIKZDFeOow27S\n//@name=DoPowerRoll\n//@img=icons/svg/dice-target.svg\ntry {\n  const powerRollStat = await game.macros.getName(`ValidateParameter`).execute({ name: `powerRollStat`, value: scope.powerRollStat, type: `string`, nullable: true });\n  const allowedEdgeBane = await game.macros.getName(`ValidateParameter`).execute({ name: `allowedEdgeBane`, value: scope.allowedEdgeBane, type: `object`, nullable: true });\n\n  // Calculate the default modifier based on the highest allowed characteristic of the power roll\n  let defaultValue = -1;\n  if (powerRollStat) {\n    const characteristics = actor.system.attributes.characteristics;\n    for (const [charName, char] of Object.entries(characteristics))\n      if (powerRollStat.toLowerCase().includes(charName) && char.value > defaultValue)\n        defaultValue = char.value;\n  }\n  else\n    defaultValue = 2;\n\n  // Show the modifier dialog\n  modifier = await game.macros.getName(`ShowSimpleInputDialog`).execute({ label: `Modifier`, defaultValue });\n  if (modifier === ``)\n    modifier = 0;\n\n  // Create the buttons and CSS for the edges and banes dialog\n  function getEdgeBaneLabel(eb) {\n    return eb === `db` ? `Double bane`\n      : eb === `b` ? `Bane`\n      : eb === `e` ? `Edge`\n      : eb === `de` ? `Double edge`\n      : `Normal roll`;\n  }\n\n  let ebButtons = {\n    db: { label: getEdgeBaneLabel(`db`), color: `#8B0000` },\n    b: { label: getEdgeBaneLabel(`b`), color: `#4D0000` },\n    n: { label: getEdgeBaneLabel(`n`), color: `#000000` },\n    e: { label: getEdgeBaneLabel(`e`), color: `#003300` },\n    de: { label: getEdgeBaneLabel(`de`), color: `#006400` }\n  };\n\n  const ebButtonStyles = `\n    <style>\n      .dialog-buttons {\n        white-space: nowrap;\n      }\n      button.db {\n        color: ${ebButtons.db.color};\n      }\n      button.b {\n        color: ${ebButtons.b.color};\n      }\n      button.n {\n        color: ${ebButtons.n.color};\n      }\n      button.e {\n        color: ${ebButtons.e.color};\n      }\n      button.de {\n        color: ${ebButtons.de.color};\n      }\n    </style>`\n\n  // Remove any buttons that aren't allowed\n  if (allowedEdgeBane)\n    for (const ebButtonCode in ebButtons)\n      if (!allowedEdgeBane.includes(ebButtonCode))\n        delete ebButtons[ebButtonCode];\n\n  // Show the edges and banes dialog\n  const edgeBane = await Dialog.wait({\n    title: `Edges & Banes`,\n    buttons: ebButtons,\n    content: ebButtonStyles\n  });\n\n  // Perform the roll and calculate the tier\n  const plusTier = edgeBane === `de`;\n  const minusTier = edgeBane === `db`;\n  const edgeBaneModifier = edgeBane === `e` ? `+ 2`\n    : edgeBane === `b` ? `- 2`\n    : ``;\n\n  const roll = await new Roll(`1d10 + 1d10 ${edgeBaneModifier} + ${modifier}`).evaluate();\n  const isCrit = roll.dice[0].total + roll.dice[1].total > 18;\n\n  let tier = roll.total < 12 ? 1\n    : roll.total < 17 ? 2\n    : 3;\n  if (plusTier & tier < 3)\n    tier++;\n  if (minusTier & tier > 1)\n    tier--;\n\n  if (roll.dice[0].total + roll.dice[1].total === 20) // Always get a tier 3 result on roll of 20\n    tier = 3;\n\n  // Display the roll\n  const flavorColor = tier === 1 ? `#800000`\n    : tier === 2 ? `#000000`\n    : `#008000`;\n  await game.macros.getName(`ShareRoll`).execute({\n    roll,\n    flavor: `<span style=\"color: ${flavorColor}; font-weight: bold;\">${isCrit ? `Critical success! ` : ``}Tier ${tier} </span>[${getEdgeBaneLabel(edgeBane)}]`\n  });\n\n  return { tier: tier, edge: edgeBane };\n}\ncatch (error) {\n  if (error.message !== \"The Dialog was closed without a choice being made.\")\n    ui.notifications.error(error);\n  else\n    throw error;\n}" }
{ "_id": "SrhPDyZWudXBRmU6", "name": "GetAttribute", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=SrhPDyZWudXBRmU6\n//@name=GetAttribute\n//@img=icons/svg/dice-target.svg\nconst attributeName = await game.macros.getName(`ValidateParameter`).execute({ name: `attributeName`, value: scope.attributeName, type: `string` });\n\nreturn attributeName === `health` ? actor.system.health\n  : attributeName === `recoveries` ? actor.system.power\n  : actor.system.attributes[attributeName];" }
{ "_id": "EaepUHVgCtZ65Sih", "name": "GetCharacteristic", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=EaepUHVgCtZ65Sih\n//@name=GetCharacteristic\n//@img=icons/svg/dice-target.svg\nconst characteristicName = await game.macros.getName(`ValidateParameter`).execute({ name: `characteristicName`, value: scope.characteristicName, type: `string` });\n\nreturn actor.system.attributes.characteristics[characteristicName.toLowerCase()].value;" }
{ "_id": "GOv0CejB17b8LXMR", "name": "GetKitDamage", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=GOv0CejB17b8LXMR\n//@name=GetKitDamage\n//@img=icons/svg/dice-target.svg\nconst isMelee = await game.macros.getName(`ValidateParameter`).execute({ name: `isMelee`, value: scope.isMelee, type: `boolean` });\nconst tier = await game.macros.getName(`ValidateParameter`).execute({ name: `tier`, value: scope.tier, type: `number` });\n\nconst kitDamageGroupName = `kit${isMelee ? `Melee` : `Ranged`}Damage`;\nconst kitDamageAttributeName = `tier${tier}`;\n\nreturn Object.hasOwn(actor.system.attributes, kitDamageGroupName) ? actor.system.attributes[kitDamageGroupName][kitDamageAttributeName].value : 0;" }
{ "_id": "czRakNtrsZFDoWij", "name": "GetPersistentCost", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=czRakNtrsZFDoWij\n//@name=GetPersistentCost\n//@img=icons/svg/dice-target.svg\nconst persistentCostString = (await game.macros.getName(`GetAttribute`).execute({ attributeName: `persistentCost` })).value;\nlet persistentCosts = {};\nif (persistentCostString)\n  for (const pc of persistentCostString.split(\";\")) {\n    const pcSplit = pc.split(\":\");\n    persistentCosts[pcSplit[0]] = Number(pcSplit[1]);\n  }\n\nreturn persistentCosts;" }
{ "_id": "SZdU9V0OWjs46fRF", "name": "GetUUID", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=SZdU9V0OWjs46fRF\n//@name=GetUUID\n//@img=icons/svg/dice-target.svg\nreturn `10000000-1000-4000-8000-100000000000`.replace(/[018]/g, c =>\n  (+c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)\n);" }
{ "_id": "wxzRAVPDMEyIoFSg", "name": "ShareAbility", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=wxzRAVPDMEyIoFSg\n//@name=ShareAbility\n//@img=icons/svg/dice-target.svg\ntry {\n  await game.macros.getName(\"ValidateActorAttributes\").execute();\n\n  const name = await game.macros.getName(`ValidateParameter`).execute({ name: `name`, value: scope.name, type: `string` });\n  const resourceCost = await game.macros.getName(`ValidateParameter`).execute({ name: `resourceCost`, value: scope.resourceCost, type: `number`, nullable: true });\n  const flavorText = await game.macros.getName(`ValidateParameter`).execute({ name: `flavorText`, value: scope.flavorText, type: `string`, nullable: true });\n  const description = await game.macros.getName(`ValidateParameter`).execute({ name: `description`, value: scope.description, type: `string`, nullable: true });\n  const type = await game.macros.getName(`ValidateParameter`).execute({ name: `type`, value: scope.type, type: `string` });\n  const keywords = await game.macros.getName(`ValidateParameter`).execute({ name: `keywords`, value: scope.keywords, type: `string`, nullable: true });\n  const isKit = await game.macros.getName(`ValidateParameter`).execute({ name: `isKit`, value: scope.isKit, type: `boolean`, nullable: true });\n  const distance = await game.macros.getName(`ValidateParameter`).execute({ name: `distance`, value: scope.distance, type: `string`, nullable: true });\n  const target = await game.macros.getName(`ValidateParameter`).execute({ name: `target`, value: scope.target, type: `string`, nullable: true });\n  const trigger = await game.macros.getName(`ValidateParameter`).execute({ name: `trigger`, value: scope.trigger, type: `string`, nullable: true });\n  const powerRollStat = await game.macros.getName(`ValidateParameter`).execute({ name: `powerRollStat`, value: scope.powerRollStat, type: `string`, nullable: true });\n  const tier1Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier1Effect`, value: scope.tier1Effect, type: `string`, nullable: true });\n  const tier2Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier2Effect`, value: scope.tier2Effect, type: `string`, nullable: true });\n  const tier3Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier3Effect`, value: scope.tier3Effect, type: `string`, nullable: true });\n  const effect = await game.macros.getName(`ValidateParameter`).execute({ name: `effect`, value: scope.effect, type: `string`, nullable: true });\n  const extraResourceCost = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceCost`, value: scope.extraResourceCost, type: `string`, nullable: true });\n  const extraResourceEffect = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceEffect`, value: scope.extraResourceEffect, type: `string`, nullable: true });\n  const persistentCost = await game.macros.getName(`ValidateParameter`).execute({ name: `persistentCost`, value: scope.persistentCost, type: `number`, nullable: true });\n  const persistentEffect = await game.macros.getName(`ValidateParameter`).execute({ name: `persistentEffect`, value: scope.persistentEffect, type: `string`, nullable: true });\n\n  const getExtraDamageFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `getExtraDamageFunc`, value: scope.getExtraDamageFunc, type: `function`, nullable: true });\n  const onUseFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `onUseFunc`, value: scope.onUseFunc, type: `function`, nullable: true });\n\n  // Perform additional validation\n  if (name.includes(`:`) || name.includes(`;`))\n    throw `Error: name cannot include \":\" or \";\"`;\n  if (typeof(resourceCost) !== `undefined` && resourceCost === 0)\n    throw `Error: resourceCost cannot be 0`;\n  if (typeof(trigger) !== `undefined` && !type.toLowerCase().includes(\"triggered\"))\n    throw `Error: trigger can only be specified for triggered actions`;\n  if (typeof(powerRollStat) !== typeof(tier1Effect) || typeof(powerRollStat) !== typeof(tier2Effect) || typeof(powerRollStat) !== typeof(tier3Effect))\n    throw `Error: powerRollStat, tier1Effect, tier2Effect, and tier3Effect must be specified together`;\n  if (typeof(extraResourceCost) !== typeof(extraResourceEffect))\n    throw `Error: extraResourceCost and extraResourceEffect must be specified together`;\n  if (typeof(extraResourceCost) !== `undefined` && !/[1-9][0-9]*\\+?/.test(extraResourceCost))\n    throw `Error: extraResourceCost cannot be 0`;\n  if ((typeof(persistentCost) !== `undefined` || typeof(persistentEffect) !== `undefined`) && (typeof(persistentCost) !== `number` || typeof(persistentEffect) !== `string`))\n    throw `Error: persistentCost and persistentEffect must be specified together`;\n  if (typeof(persistentCost) !== `undefined` && persistentCost === 0)\n    throw `Error: persistentCost cannot be 0`;\n\n  // Calculate values for showing the \"Use\" button\n  const buttonId = await game.macros.getName(`GetUUID`).execute();\n\n  const resource = await game.macros.getName(`GetAttribute`).execute({ attributeName: `resource` });\n\n  const showUseButton = resourceCost || extraResourceCost || powerRollStat || onUseFunc;\n  const canUse = showUseButton && (typeof(resourceCost) === `undefined` || resource.value >= resourceCost);\n\n  // Calculate the colour for the ability type\n  const actionColor = type === `Action` ? `rgb(166, 28, 0)`\n    : type === `Maneuver` ? `rgb(61, 133, 198)`\n    : type === `Triggered` ? `rgb(56, 118, 29)`\n    : type === `Free Triggered` ? `rgb(191, 144, 0)`\n    : `black`;\n\n  // Define function for highlighting any potencies in power roll results\n  function highlightPotencyFunc(tierEffect) {\n    return tierEffect.replaceAll(/([A-Z]\\s+<\\s+[A-Z0-9]+)/gi, `<span style=\"color: red\">$1</span>`);\n  }\n\n  function includeClosingPIfNotClosed(text) {\n    return `${text}${text.includes(`</p>`) ? `` : `</p>`}`;\n  }\n\n  // Show the ability in the chat\n  await ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    flags: { \"core.canPopout\": true },\n    content:\n      `<h2 style=\"border-color: ${actionColor}; border-width: 2px;\">${name}${(resourceCost ? ` <span style=\"font-size: 80%; font-style: italic;\"> (${resourceCost} ${resource.label})</span>` : ``)}</h2>\n      ${(flavorText? `<p style=\"font-style: italic;\">${flavorText}</p>` : ``)}\n      <table style=\"border: 0px; table-layout: fixed;\">\n      ${(keywords ? `\n        <tr>\n          <td><b>Keywords:</b> ${keywords}</td>\n        </tr>\n      ` : ``)}\n        <tr>\n          <td><b>Type:</b> ${type}</td>\n        </tr>\n      ${(distance ? `\n        <tr>\n          <td><b>Distance:</b> ${distance}</td>\n        </tr>\n      ` : ``)}\n      ${(target ? `\n        <tr>\n          <td><b>Target:</b> ${target}</td>\n        </tr>\n      ` : ``)}\n      </table>\n      ${(description ? `<p>${includeClosingPIfNotClosed(description)}` : ``)}\n      ${(trigger ? `<p><b>Trigger:</b> ${trigger}</p>` : ``)}\n      ${(powerRollStat ? `\n        <p style=\"font-weight: bold;\">Power Roll + ${powerRollStat}:</p>\n        <ul>\n          <li><b>&lt;11:</b> ${highlightPotencyFunc(tier1Effect)}</li>\n          <li><b>12-16:</b> ${highlightPotencyFunc(tier2Effect)}</li>\n          <li><b>17+:</b> ${highlightPotencyFunc(tier3Effect)}</li>\n        </ul>\n      ` : ``)}\n      ${(effect ? `<p><b>Effect:</b> ${includeClosingPIfNotClosed(effect)}` : ``)}\n      ${(persistentCost ? `<p><b>Persistent ${persistentCost}:</b> ${includeClosingPIfNotClosed(persistentEffect)}` : ``)}\n      ${(extraResourceCost ? `<p><b>Spend ${extraResourceCost} ${resource.label}:</b> ${includeClosingPIfNotClosed(extraResourceEffect)}` : ``)}\n      ${(showUseButton ? `<button id=\"${buttonId}\">${(canUse ? `Use` : `Not enough ${resource.label}`)}</button>` : ``)}`\n  });\n\n  // Register event for the \"Use\" button\n  if (showUseButton) {\n    $(document).on(`click`, `#${buttonId}`, async function() {\n      const button = $(this);\n      await game.macros.getName(`UseAbility`).execute({\n        button,\n        name,\n        keywords,\n        isKit,\n        resourceCost,\n        extraResourceCost,\n        persistentCost,\n        powerRollStat,\n        tier1Effect,\n        tier2Effect,\n        tier3Effect,\n        getExtraDamageFunc,\n        onUseFunc\n      });\n    });\n  }\n}\ncatch (error) {\n  ui.notifications.error(error);\n}" }
{ "_id": "aUX7yxzO8WBIhCKP", "name": "ShareFeature", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=aUX7yxzO8WBIhCKP\n//@name=ShareFeature\n//@img=icons/svg/dice-target.svg\ntry {\n  await game.macros.getName(\"ValidateActorAttributes\").execute();\n\n  const name = await game.macros.getName(`ValidateParameter`).execute({ name: `name`, value: scope.name, type: `string` });\n  const description = await game.macros.getName(`ValidateParameter`).execute({ name: `description`, value: scope.description, type: `string` });\n  const source = await game.macros.getName(`ValidateParameter`).execute({ name: `source`, value: scope.source, type: `string` });\n\n  const onUseFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `onUseFunc`, value: scope.onUseFunc, type: `function`, nullable: true });\n\n  // Calculate values for showing the \"Use\" button\n  const buttonId = await game.macros.getName(`GetUUID`).execute();\n\n  // Show the ability in the chat\n  await ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    flags: { \"core.canPopout\": true },\n    content:\n      `<h2 style=\"border-color: black; border-width: 2px;\">${name} <span style=\"font-size: 80%; color: gray;\"> [${source}]</span></h2>\n      <p>${description}${description.includes(`</p>`) ? `` : `</p>`}\n      ${(onUseFunc ? `<button id=\"${buttonId}\">Use</button>` : ``)}`\n  });\n\n  // Register event for the \"Use\" button\n  if (onUseFunc) {\n    $(document).on(`click`, `#${buttonId}`, async function() {\n      await onUseFunc();\n\n      // Disable this event and delete the button\n      $(this).off(`click`);\n      $(this).remove();\n    });\n  }\n}\ncatch (error) {\n  ui.notifications.error(error);\n}" }
{ "_id": "rJPRglQIz1eHFSab", "name": "ShareRoll", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=rJPRglQIz1eHFSab\n//@name=ShareRoll\n//@img=icons/svg/dice-target.svg\nconst roll = await game.macros.getName(`ValidateParameter`).execute({ name: `roll`, value: scope.roll, type: `object` });\nconst flavor = await game.macros.getName(`ValidateParameter`).execute({ name: `flavor`, value: scope.flavor, type: `string` });\n\nconst message = await roll.toMessage({\n  speaker: ChatMessage.implementation.getSpeaker({actor}),\n  flavor\n});\nif (game.dice3d && roll.dice.length > 0)\n  await game.dice3d.waitFor3DAnimationByMessageID(message.id);" }
{ "_id": "96WYstdKircGE5Th", "name": "ShowPersistentCostDialog", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=96WYstdKircGE5Th\n//@name=ShowPersistentCostDialog\n//@img=icons/svg/dice-target.svg\nconst label = await game.macros.getName(`ValidateParameter`).execute({ name: `label`, value: scope.label, type: `string` });\nconst resourceLabel = await game.macros.getName(`ValidateParameter`).execute({ name: `resourceLabel`, value: scope.resourceLabel, type: `string` });\nconst selectByDefault = (await game.macros.getName(`ValidateParameter`).execute({ name: `selectByDefault`, value: scope.selectByDefault, type: `boolean`, nullable: true })) ?? false;\n\nconst persistentCosts = await game.macros.getName(`GetPersistentCost`).execute();\nif (!Object.keys(persistentCosts).length)\n  return undefined;\n\nlet persistCostOptions = ``;\nlet counter = 0;\nfor (const [abilityName, cost] of Object.entries(persistentCosts))\n  persistCostOptions += `\n    <div>\n      <input id=\"persistentCost${counter++}\" type=\"checkbox\" style=\"vertical-align: middle;\" name=\"persistentCosts\" value=\"${abilityName}\"${selectByDefault ? ` checked` : ``}/>\n      <label style=\"vertical-align: middle;\" for=\"persistentCost${counter}\">${abilityName} <i>(${cost} ${resourceLabel})</i></label>\n    </div>`;\n\nreturn await Dialog.prompt({\n  title: `Persistent cost`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <fieldset>\n          <legend>${label}:</legend>\n          ${persistCostOptions}\n        </fieldset>\n      </div>\n    </form>`,\n  callback: html => html.find('input[name=\"persistentCosts\"]:checked').get().map(i => i.value)\n});" }
{ "_id": "AQTxaEf8itGUMpOR", "name": "ShowSimpleInputDialog", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=AQTxaEf8itGUMpOR\n//@name=ShowSimpleInputDialog\n//@img=icons/svg/dice-target.svg\nconst label = await game.macros.getName(`ValidateParameter`).execute({ name: `label`, value: scope.label, type: `string` });\nconst title = (await game.macros.getName(`ValidateParameter`).execute({ name: `label`, value: scope.label, type: `string`, nullable: true })) ?? label;\nconst allowNegative = (await game.macros.getName(`ValidateParameter`).execute({ name: `allowNegative`, value: scope.allowNegative, type: `boolean`, nullable: true })) ?? true;\nconst defaultValue = (await game.macros.getName(`ValidateParameter`).execute({ name: `defaultValue`, value: scope.defaultValue, type: `number`, nullable: true })) ?? 0;\nconst rejectClose = (await game.macros.getName(`ValidateParameter`).execute({ name: `rejectClose`, value: scope.rejectClose, type: `boolean`, nullable: true })) ?? true;\n\nreturn await Dialog.prompt({\n  title,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>${label}:</label>\n        <div class=\"form-fields\">\n          <input type=\"number\" onkeypress=\"return ((event.key >= '0' && event.key <= '9')${allowNegative ? ` || event.key === '-'` : ``})\" value=\"${defaultValue}\" autofocus onFocus=\"this.select()\"/>\n        </div>\n      </div>\n    </form>`,\n  rejectClose,\n  callback: html => html.find('input').val()\n});" }
{ "_id": "SQXPenBmpa0GCwc3", "name": "StartTurn", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=SQXPenBmpa0GCwc3\n//@name=StartTurn\n//@img=icons/svg/dice-target.svg\ntry {\n  await game.macros.getName(\"ValidateActorAttributes\").execute();\n\n  const resourceRoll = (await game.macros.getName(`ValidateParameter`).execute({ name: `resourceRoll`, value: scope.resourceRoll, type: `string`, nullable: true })) ?? `1d3`;\n\n  const resourceAttribute = await game.macros.getName(`GetAttribute`).execute({ attributeName: `resource` });\n\n  // If any persistent abilities are active, show a selector for those that should be maintained, and calculate the cost\n  let persistentCost = 0;\n  const currPersistentCosts = await game.macros.getName(`GetPersistentCost`).execute();\n  if (Object.keys(currPersistentCosts).length) {\n    if (resourceRoll.includes(\"d\"))\n      throw `Error: Handling of persistent effects with variable resource gain is not implemented`;\n\n    const abilitiesToMaintain = await game.macros.getName(\"ShowPersistentCostDialog\").execute({ label: `Persistent effects to maintain`, resourceLabel: resourceAttribute.label, selectByDefault: true });\n    for (const abilityName of abilitiesToMaintain)\n      persistentCost += currPersistentCosts[abilityName];\n\n    if (resourceRoll - persistentCost < 0) {\n      ui.notifications.error(`Not enough ${resourceAttribute.label} to maintain all persistent effects!`);\n      return;\n    }\n\n    for (const [abilityName, cost] of Object.entries(currPersistentCosts))\n      if (!abilitiesToMaintain.includes(abilityName))\n        await game.macros.getName(`UpdatePersistentCost`).execute({ abilityName });\n  }\n\n  const roll = await new Roll(`${resourceAttribute.value} + ${resourceRoll}${persistentCost > 0 ? ` - ${persistentCost}` : ``}`).evaluate();\n  await game.macros.getName(`ShareRoll`).execute({\n    roll,\n    flavor: resourceAttribute.label.capitalize()\n  });\n\n  await game.macros.getName(`UpdateAttribute`).execute({ attributeName: `resource`, value: roll.total });\n}\ncatch (error) {\n  if (error.message !== \"The Dialog was closed without a choice being made.\")\n    ui.notifications.error(error);\n}" }
{ "_id": "inREdrJwhy1tXNak", "name": "UpdateAttribute", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=inREdrJwhy1tXNak\n//@name=UpdateAttribute\n//@img=icons/svg/dice-target.svg\nconst attributeName = await game.macros.getName(`ValidateParameter`).execute({ name: `attributeName`, value: scope.attributeName, type: `string` });\nconst value = await game.macros.getName(`ValidateParameter`).execute({ name: `value`, value: scope.value, type: `number` });\nconst isDelta = (await game.macros.getName(`ValidateParameter`).execute({ name: `isDelta`, value: scope.isDelta, type: `boolean`, nullable: true })) ?? false;\n\nconst attribute = await game.macros.getName(`GetAttribute`).execute({ attributeName });\nconst attributePath = attributeName === `health` ? `health`\n  : attributeName === `recoveries` ? `power`\n  : `attributes.${attributeName}`;\n\nawait actor.update({ [`system.${attributePath}.value`]: isDelta ? attribute.value + value : value });\n\nreturn await game.macros.getName(`GetAttribute`).execute({ attributeName });" }
{ "_id": "D6zoUBTvy8YqVhKc", "name": "UpdatePersistentCost", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=D6zoUBTvy8YqVhKc\n//@name=UpdatePersistentCost\n//@img=icons/svg/dice-target.svg\nconst abilityName = await game.macros.getName(`ValidateParameter`).execute({ name: `abilityName`, value: scope.abilityName, type: `string`, nullable: true });\nconst cost = await game.macros.getName(`ValidateParameter`).execute({ name: `cost`, value: scope.cost, type: `number`, nullable: true });\n\nif (cost && !abilityName)\n  throw `Error: Cost with no ability name`;\n\nlet value = ``;\nif (abilityName) {\n  const persistentCosts = await game.macros.getName(`GetPersistentCost`).execute();\n\n  if (cost)\n    persistentCosts[abilityName] = cost;\n  else\n    delete persistentCosts[abilityName];\n\n  value = Object.entries(persistentCosts).map(([k,v]) => `${k}:${v}`).join(';');\n}\n\nconst attributeName = `persistentCost`;\nconst attributePath = `system.attributes.${attributeName}.value`;\n\nawait actor.update({ [attributePath]: value });\n\nreturn await game.macros.getName(`GetAttribute`).execute({ attributeName });" }
{ "_id": "UvSBFc1YuHe5kiDW", "name": "UseAbility", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=UvSBFc1YuHe5kiDW\n//@name=UseAbility\n//@img=icons/svg/dice-target.svg\ntry {\n  await game.macros.getName(\"ValidateActorAttributes\").execute();\n\n  const button = await game.macros.getName(`ValidateParameter`).execute({ name: `button`, value: scope.button, type: `object` });\n\n  const name = await game.macros.getName(`ValidateParameter`).execute({ name: `name`, value: scope.name, type: `string` });\n  const resourceCost = await game.macros.getName(`ValidateParameter`).execute({ name: `resourceCost`, value: scope.resourceCost, type: `number`, nullable: true });\n  const extraResourceCost = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceCost`, value: scope.extraResourceCost, type: `string`, nullable: true });\n  const persistentCost = await game.macros.getName(`ValidateParameter`).execute({ name: `persistentCost`, value: scope.persistentCost, type: `number`, nullable: true });\n  const powerRollStat = await game.macros.getName(`ValidateParameter`).execute({ name: `powerRollStat`, value: scope.powerRollStat, type: `string`, nullable: true });\n  const tier1Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier1Effect`, value: scope.tier1Effect, type: `string`, nullable: true });\n  const tier2Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier2Effect`, value: scope.tier2Effect, type: `string`, nullable: true });\n  const tier3Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier3Effect`, value: scope.tier3Effect, type: `string`, nullable: true });\n  const keywords = (await game.macros.getName(`ValidateParameter`).execute({ name: `keywords`, value: scope.keywords, type: `string`, nullable: true })) ?? ``;\n  const isKit = (await game.macros.getName(`ValidateParameter`).execute({ name: `isKit`, value: scope.isKit, type: `boolean`, nullable: true })) ?? false;\n\n  const getExtraDamageFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `getExtraDamageFunc`, value: scope.getExtraDamageFunc, type: `function`, nullable: true });\n  const onUseFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `onUseFunc`, value: scope.onUseFunc, type: `function`, nullable: true });\n\n  // Determine if the ability can actually be used\n  const currResource = await game.macros.getName(`GetAttribute`).execute({ attributeName: `resource` });\n  let actualResourceCost = resourceCost;\n\n  // Handle free persistent effect\n  const persistentCosts = await game.macros.getName(`GetPersistentCost`).execute();\n  if (Object.keys(persistentCosts).length && Object.hasOwn(persistentCosts, name)) {\n    const isPersistent = await Dialog.confirm({\n      title: `Persistent effect?`,\n      content: `<p>Are you using the persistent effect of <i>${name}</i>?</p>`,\n      defaultYes: false\n    });\n    actualResourceCost = isPersistent ? 0 : resourceCost;\n  }\n\n  // Handle Shadow ability cost reduction\n  const className = (await game.macros.getName(`GetAttribute`).execute({ attributeName: `class` })).value;\n  let allowedEdgeBane = undefined;\n  if (className.toLowerCase() === \"shadow\" && actualResourceCost && powerRollStat) {\n    const decreaseCost = await Dialog.confirm({\n      title: `Edge?`,\n      content: `<p>Will you have an edge on the power roll (against at least one target)?</p>`,\n      rejectClose: true\n    });\n\n    if (decreaseCost) {\n      --actualResourceCost;\n      allowedEdgeBane = ['de', 'e'];\n    }\n    else\n      allowedEdgeBane = ['n', 'b', 'db'];\n  }\n\n  if (actualResourceCost && currResource.value < actualResourceCost) {\n    ui.notifications.info(`Not enough ${currResource.label}!`);\n    return;\n  }\n\n  if (onUseFunc)\n    await onUseFunc();\n\n  // Perform the power roll, if the ability has a power roll\n  let rollResult = undefined;\n  if (powerRollStat) {\n    rollResult = (await game.macros.getName(`DoPowerRoll`).execute({ powerRollStat, allowedEdgeBane }));\n\n    // Calculate the damage of the ability\n    const effect = [ tier1Effect, tier2Effect, tier3Effect ][rollResult.tier - 1];\n    const matches = effect.match(/^(([0-9]+d[0-9]+)\\s+\\+\\s+)?([0-9]+)(\\s+\\+\\s+[MAIRPor,\\s]+)?\\s+((acid|cold|corruption|fire|holy|lightning|poison|psychic|sonic)\\s+)?damage/);\n    const doesDamage = matches !== null;\n    if (doesDamage) {\n      const diceDamage = matches[2];\n      const constDamage = matches[3];\n      const charDamageOptions = matches[4];\n      const damageType = matches[6];\n\n      // Calculate the damage from the highest characteristic\n      let charDamage = undefined;\n      let maxCharName = undefined;\n      if (charDamageOptions) {\n        for (const [charName, char] of Object.entries(actor.system.attributes.characteristics))\n          if (charDamageOptions.indexOf(charName[0].toUpperCase()) >= 0 && (!maxCharName || char.value > charDamage)) {\n            maxCharName = charName;\n            charDamage = char.value;\n          }\n      }\n\n      // Calculate the damage from the kit (if this isn't a kit ability)\n      const isMelee = keywords.toLowerCase().includes(\"melee\");\n      const isRanged = keywords.toLowerCase().includes(\"ranged\");\n      const kitDamage = (!isMelee && !isRanged) || isKit ? 0 : await game.macros.getName(`GetKitDamage`).execute({ isMelee, tier: rollResult.tier });\n\n      let extraDamage = undefined;\n      if (getExtraDamageFunc)\n        extraDamage = await getExtraDamageFunc();\n\n      let damageRollString = ``;\n      if (diceDamage)\n        damageRollString += diceDamage + ` + `;\n      damageRollString += constDamage;\n      if (charDamage)\n        damageRollString += ` + ` + charDamage + `[${maxCharName[0].toUpperCase()}]`;\n      if (!isKit)\n        damageRollString += ` + ` + kitDamage + `[kit]`;\n      if (extraDamage)\n        damageRollString += extraDamage;\n\n      const damageRoll = await new Roll(damageRollString).evaluate();\n      await game.macros.getName(`ShareRoll`).execute({\n        roll: damageRoll,\n        flavor: damageType ? `${damageType.capitalize()} damage` : `Damage`\n      });\n    }\n\n    // Determine if any surges should be used\n    const hasPotency = /([A-Z]\\s+<\\s+[A-Z0-9]+)/i.test(effect);\n    const surgeCount = (await game.macros.getName(`GetAttribute`).execute({ attributeName: `surges` })).value;\n    if (doesDamage && surgeCount > 0 || hasPotency && surgeCount >= 2) {\n      let surgeButtons = {\n        z: { label: `0` }\n      }\n      if (doesDamage)\n        surgeButtons.d1 = { label: `1 (damage)` };\n      if (surgeCount >= 2) {\n        if (doesDamage)\n          surgeButtons.d2 = { label: `2 (damage)` };\n        if (hasPotency)\n          surgeButtons.p2 = { label: `2 (potency)` };\n      }\n      if (surgeCount >= 3)\n        surgeButtons.d3 = { label: `3 (damage)` };\n\n      const surgeButtonStyles = `\n        <style>\n          .dialog-buttons {\n            white-space: nowrap;\n          }\n          button.d1, button.d2, button.d3 {\n            color: darkred;\n          }\n          button.p2 {\n            color: darkblue;\n          }\n        </style>`;\n\n      const surgesUsed = await Dialog.wait({\n        title: `Surges to use`,\n        buttons: surgeButtons,\n        content: surgeButtonStyles,\n        close: () => { return 0; }\n      });\n\n      // If surges should be used, subtract the surges, and send an additional roll for surge damage if used for damage\n      if (surgesUsed && surgesUsed !== `z`) {\n        const damageSurges = surgesUsed.startsWith(`d`) ? Number(surgesUsed.substring(1)) : 0;\n        const potencySurges = surgesUsed.startsWith(`p`) ? Number(surgesUsed.substring(1)) : 0;\n\n        // Handle Shadow resource gain when using a surges for damage for the first time in a round\n        if (className.toLowerCase() === \"shadow\" && damageSurges > 0) {\n          const firstSurge = await Dialog.confirm({\n            title: `First surge?`,\n            content: `<p>Is this the first surge used this round?</p>`,\n            defaultYes: false\n          });\n          if (firstSurge)\n            await game.macros.getName(`UpdateAttribute`).execute({ attributeName: `resource`, value: 1, isDelta: true });\n        }\n\n        if (damageSurges > 0) {\n          const characteristics = actor.system.attributes.characteristics;\n          const maxChar = Math.max(...(Object.keys(characteristics).map((key) => characteristics[key].value)));\n          const surgeDamage = (damageSurges * maxChar);\n          const surgeRoll = await new Roll(surgeDamage.toString()).evaluate();\n          await game.macros.getName(`ShareRoll`).execute({\n            roll: surgeRoll,\n            flavor: `Extra damage`\n          });\n        }\n\n        await game.macros.getName(`UpdateAttribute`).execute({ attributeName: `surges`, value: -(damageSurges + potencySurges), isDelta: true });\n      }\n    }\n  }\n\n  // Set the persistent cost, if the ability has a persistent cost\n  if (persistentCost) {\n    await game.macros.getName(`UpdatePersistentCost`).execute({ abilityName: name, cost: persistentCost });\n  }\n\n  // Subtract the resource cost, if the ability has a resource cost\n  if (actualResourceCost || extraResourceCost) {\n    let totalResourceCost = actualResourceCost ?? 0;\n\n    // Determine if extra resource should be used and use it if so\n    if (extraResourceCost) {\n      let extraResourceUsed = 0;\n\n      const isExtraResourceCostVariable = extraResourceCost.endsWith(`+`);\n      const minExtraResourceCost = Number(isExtraResourceCostVariable ? extraResourceCost.substring(0, extraResourceCost.length - 1) : extraResourceCost);\n\n      // If the extra resource ends with a \"+\", then a variable amount can be used\n      if (isExtraResourceCostVariable) {\n        if (currResource.value >= totalResourceCost + minExtraResourceCost) {\n          extraResourceUsed = Number((await game.macros.getName(`ShowSimpleInputDialog`).execute({ title: `Extra ${currResource.label}`, label: `Extra ${currResource.label} to use`, defaultValue: minExtraResourceCost, allowNegative: false, rejectClose: false })) ?? 0);\n\n          // Ensure the minimum resource was used\n          if (extraResourceUsed > 0 && extraResourceUsed < minExtraResourceCost) {\n            extraResourceUsed = 0;\n            ui.notifications.warn(`Extra effect requires at least ${minExtraResourceCost} ${currResource.label} to be used! No extra ${currResource.label} was used.`);\n          }\n          // Ensure that the actor has enough resource\n          else if (currResource.value < totalResourceCost + extraResourceUsed) {\n            extraResourceUsed = currResource.value - totalResourceCost;\n            ui.notifications.warn(`Not enough ${currResource.label}! ${extraResourceUsed} ${currResource.label} will be used instead.`);\n          }\n        }\n      }\n      // If the extra resource doesn't end with a \"+\", then exactly that amount must be used\n      else if (currResource.value >= totalResourceCost + minExtraResourceCost)\n        extraResourceUsed = await Dialog.confirm({\n          title: `Extra ${currResource.label}`,\n          content: `<p>Use extra ${minExtraResourceCost} ${currResource.label}?</p>`,\n          defaultYes: false\n        }) ? minExtraResourceCost : 0;\n\n      totalResourceCost += extraResourceUsed;\n    }\n\n    if (totalResourceCost > 0) {\n      await game.macros.getName(`UpdateAttribute`).execute({ attributeName: `resource`, value: -totalResourceCost, isDelta: true });\n    }\n  }\n\n  // Disable this event and delete the button\n  button.off(`click`);\n  button.remove();\n}\ncatch (error) {\n  if (error.message !== \"The Dialog was closed without a choice being made.\")\n    ui.notifications.error(error);\n}" }
{ "_id": "1JFEp3M9VhftSyuZ", "name": "ValidateActorAttributes", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=1JFEp3M9VhftSyuZ\n//@name=ValidateActorAttributes\n//@img=icons/svg/dice-target.svg\nfunction validateHasOwn(obj, propName, actor, isGroup = false) {\n  if (!Object.hasOwn(obj, propName))\n    throw `Error: ${isGroup ? `Group` : `Attribute`} \"${propName}\" is not defined for actor \"${actor.name}\"`;\n}\n\nfunction validateIsType(obj, propName, type, actor) {\n  if (obj[propName].dtype.toLowerCase() !== type)\n    throw `Error: Attribute \"${propName}\" for actor \"${actor.name}\" does not have \"${type}\" type`;\n}\n\nfunction validateHasOwnOfType(obj, propName, type, actor) {\n  validateHasOwn(obj, propName, actor, false);\n  validateIsType(obj, propName, type, actor);\n}\n\nfunction validateHasNumberWithValue(obj, propName, actor) {\n  validateHasOwnOfType(obj, propName, `number`, actor, false);\n  if (!obj[propName].value)\n    throw `Error: Attribute \"${propName}\" for actor \"${actor.name}\" has no value`;\n}\n\nfunction validateHasNonEmptyLabel(obj, propName, actor) {\n  if (!obj[propName].label)\n    throw `Error: Attribute \"${propName}\" for actor \"${actor.name}\" has no label`;\n}\n\nif (!actor)\n  throw `Error: No token is selected`;\n\nfor (const attr of [`resource`, `surges`, `victories`, `level`])\n  validateHasOwnOfType(actor.system.attributes, attr, `number`, actor);\nvalidateHasNonEmptyLabel(actor.system.attributes, `resource`, actor);\nfor (const attr of [`persistentCost`, `class`])\n  validateHasOwnOfType(actor.system.attributes, attr, `string`, actor);\n\nvalidateHasOwn(actor.system.groups, `characteristics`, actor, true);\nvalidateHasOwn(actor.system.attributes, `characteristics`, actor);\nfor (const attr of [`might`, `agility`, `intuition`, `reason`, `presence`])\n  validateHasNumberWithValue(actor.system.attributes.characteristics, attr, actor);\n\nif (Object.hasOwn(actor.system.groups, `kitMeleeDamage`)) {\n  validateHasOwn(actor.system.attributes, `kitMeleeDamage`, actor);\n  for (const attr of [`tier1`, `tier2`, `tier3`])\n    validateHasNumberWithValue(actor.system.attributes.kitMeleeDamage, attr, actor);\n}\n\nif (Object.hasOwn(actor.system.groups, `kitRangedDamage`)) {\n  validateHasOwn(actor.system.attributes, `kitRangedDamage`, actor);\n  for (const attr of [`tier1`, `tier2`, `tier3`])\n    validateHasNumberWithValue(actor.system.attributes.kitRangedDamage, attr, actor);\n}" }
{ "_id": "dlDYABs6ha9yUIOr", "name": "ValidateParameter", "scope": "global", "type": "script", "permission": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=dlDYABs6ha9yUIOr\n//@name=ValidateParameter\n//@img=icons/svg/dice-target.svg\nconst name = scope.name;\nconst value = scope.value;\nconst type = scope.type;\nconst nullable = scope.nullable ?? false;\n\nfunction throwError(name, type) {\n  throw `Error: ${name} is not a valid ${type}`;\n}\n\nfunction validateString(name, value) {\n  if (typeof(value) !== `string` || value.length === 0)\n    throwError(name, `non-empty string`);\n}\nfunction validateBoolean(name, value) {\n  if (typeof(value) !== `boolean`)\n    throwError(name, `boolean`);\n}\n\nvalidateString(`name`, name);\nvalidateString(`type`, type);\nvalidateBoolean(`boolean`, nullable);\n\nif (!nullable || typeof(value) !== `undefined`) {\n  if (type === `string`)\n    validateString(name, value);\n  else if (type === `boolean`)\n    validateBoolean(name, value);\n  else if (type === `number`) {\n    if (typeof(value) !== `number` || isNaN(value))\n      throwError(name, `number`);\n  }\n  else if (type === `function`) {\n    if (typeof(value) !== `function`)\n      throwError(name, `function`);\n  }\n  else if (type === `object`) {\n    if (typeof(value) !== `object`)\n      throwError(name, `object`);\n  }\n  else\n    throw `Error: Parameter type is unsupported`;\n}\n\nreturn value;" }
